{
    "docs": [
        {
            "location": "/", 
            "text": "GenomicVectors\n\n\n\n\nIntroduction\n\n\nGenomicVectors\n is an alternate implementation of the \nGPos\n and \nGenomicRanges\n types from Bioconductor's GenomicRanges package by P. Aboyoun, H. Pages and M. Lawrence. These \nGenomicPositions\n and \nGenomicRanges\n types are \nVectors\n that serve as markers of locations on a given genome. They can be used independently or as indices and/or annotation on other objects.\n\n\nThese types are commonly used in conjuction with \nRLEVectors\n from the package of the same name, which also often contain data arrayed along a genome. For example \nGenomicDataFrame\n may use a \nGPos\n or \nGenomicRanges\n as a row index and use \nRLEVector\n objects for data columns. This is a common method of storing segmented DNA copy number for multiple samples in R's \ngenoset\n package.\n\n\n\n\nImplementation\n\n\nThese \nVector\n types each contain a \nGenomicInfo\n object, which annotates the names of the relevant genome and its chromosomes as well as the lengths of each chromosome. Operations on two or more of these genomic vectors require that they contain identical \nGenomeInfo\n objects.\n\n\nThe primary \"innovation\" of these types is that genome locations are stored as the 1-based index into the linear genome of concatenated chromosomes described by the immutable \nGenomeInfo\n object. The relevant chromosome for this \ngenopos\n can be looked up efficiently as the \nGenomeInfo\n holds the \ncumsum\n of the chromosome lengths. Using binary search and the usual optimization for a sorted vector of queries, these lookups are O(numpositions * log(numchromosomes)) in the worst case and O(numpositions) in the best case.\n\n\n\n\nCreation\n\n\nGenomeInfo\n and \nGenomicPositions\n objects can be created as follows:\n\n\nusing GenomicVectors\n\nchrinfo = GenomeInfo(\nhg19\n,[\nchr1\n,\nchr2\n,\nchrX\n],Int64[3e5,2e5,1e4])\nchrs = [\nchr1\n,\nchr2\n,\nchr2\n,\nchrX\n]\npos = Int64[3e5,1.8e5,1.9e5,1e4]\n\nx = GenomicPositions(pos,chrs,chrinfo)\n\ngpos = genopos(pos,chrs,chrinfo)\ny = GenomicPositions(gpos,chrinfo)\n\n\n\n\n\n\nDescribing\n\n\nGenomeInfo\n objects have various accessors that describe the chomosomes and their boundaries in the concatenated, linear genome. They are also immutable so that the meaning of indices into a concatenated genome cannot change unexpectedly. Objects that contain a \nGenomeInfo\n implement the same methods.\n\n\nchrinfo = GenomeInfo(\nhg19\n,[\nchr1\n,\nchr2\n,\nchrX\n],Int64[3e5,2e5,1e4])\ngenome(chrinfo)\nchr_names(chrinfo)\nchr_ends(chrinfo)\nchr_lengths(chrinfo)\nchr_offsets(chrinfo)\n\nchrs = [\nchr1\n,\nchr2\n,\nchr2\n,\nchrX\n]\npos = Int64[3e5,1.8e5,1.9e5,1e4]\nx = GenomicPositions(pos,chrs,chrinfo)\nchr_names(x)\nchr_ends(x)\nchr_lengths(x)\nchr_offsets(x)\n\n\n\n\nSimilarly, \nGenomicPositions\n and similar objects can describe the positions they represent. \nGenomicRanges\n and \nGenomicPositions\n have the same API, for interchangeability, even when functions are more naturally position- or range-related. Some of these functions are shared with \nRLEVectors\n as ranges and runs have much in common.\n\n\nchrinfo = GenomeInfo(\nhg19\n,[\nchr1\n,\nchr2\n,\nchrX\n],Int64[3e5,2e5,1e4])\nchrs = [\nchr1\n,\nchr2\n,\nchr2\n,\nchrX\n]\npos = Int64[3e5,1.8e5,1.9e5,1e4]\nx = GenomicPositions(pos,chrs,chrinfo)\nchrpos(x)\nstarts(x)\nends(x)\nwidths(x)\n\n\n\n\n\n\nWorking with locations\n\n\nGenome locations may be modified (slid along the genome, resized, etc.) in various ways, but operations that would exceed the bounds of the relevant chromosome generate errors.\n\n\nQueries of a genomic vector are only relevant in the context of a specific genome. Therefore, comparisons are only implemented between the collection of types that can be checked for identical \nGenomeInfo\n information.\n\n\nStandard vector item matching operations require identity of items, rather than overlapping ranges. Overlap operations are implemented as distinct functions, as in Bioconductor.\n\n\nchrinfo = GenomeInfo(\nGRCh38\n,[\nchr1\n,\nchr2\n,\nchr3\n,\nchrX\n,\nchrY\n,\nchrM\n],Int64[3e5,2e5,1e4,5e4,2e3,1e3])\nx = GenomicPositions( [ 200,100,150,50,500,20000], [\nchr2\n,\nchr2\n,\nchr2\n,\nchrM\n,\nchrY\n,\nchr1\n], chrinfo)\ny = GenomicPositions( [ 220,100,50,50,420,10000], [\nchr2\n,\nchr2\n,\nchr2\n,\nchrM\n,\nchrY\n,\nchr1\n], chrinfo)\nx in y\nindexin(x,y)\nslide!(x,20)\nx in y\noverlaps(x,y)\n\n\n\n\n\n\n\nOrdering\n\n\nGiven the linearized representation of the genome, ordering operations are done with respect first to position within a chromosome and then to the order of chromosomes specified in the contained \nGenomeInfo\n object. Stand, for types that implement it, is not considered in ordering. This is different than how strand is handled in R's Bioconductor classes.\n\n\nusing DataFrames\nchrinfo = GenomeInfo(\nGRCh38\n,[\nchr1\n,\nchr2\n,\nchr3\n,\nchrX\n,\nchrY\n,\nchrM\n],Int64[3e5,2e5,1e4,5e4,2e3,1e3])\nx = GenomicPositions( [ 200,100,150,50,500,20000], [\nchr2\n,\nchr2\n,\nchr2\n,\nchrM\n,\nchrY\n,\nchr1\n], chrinfo)\nsortperm(x)\nsort!(x,rev=true)\nissorted(x)\ny = sort(x)\nissorted(y)\nconvert(DataFrame, y)\n\n\n\n\n\n\nIntersection / overlap operations\n\n\nCurrently we depend on Bio.jl and the \nIntervalCollection\n for overlap queries. We provide \nconvert\n methods to make \nIntervalCollection\ns. These collections store the genome-scale positions put the genome string in the chromosome string field, resulting in a single tree. We add the index of each interval in the \nAbstractGenomicVector\n in the metadata slot of each \nInterval\n which can be used to relate the \nIntervalCollection\n back to our original object.", 
            "title": "Home"
        }, 
        {
            "location": "/#genomicvectors", 
            "text": "", 
            "title": "GenomicVectors"
        }, 
        {
            "location": "/#introduction", 
            "text": "GenomicVectors  is an alternate implementation of the  GPos  and  GenomicRanges  types from Bioconductor's GenomicRanges package by P. Aboyoun, H. Pages and M. Lawrence. These  GenomicPositions  and  GenomicRanges  types are  Vectors  that serve as markers of locations on a given genome. They can be used independently or as indices and/or annotation on other objects.  These types are commonly used in conjuction with  RLEVectors  from the package of the same name, which also often contain data arrayed along a genome. For example  GenomicDataFrame  may use a  GPos  or  GenomicRanges  as a row index and use  RLEVector  objects for data columns. This is a common method of storing segmented DNA copy number for multiple samples in R's  genoset  package.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#implementation", 
            "text": "These  Vector  types each contain a  GenomicInfo  object, which annotates the names of the relevant genome and its chromosomes as well as the lengths of each chromosome. Operations on two or more of these genomic vectors require that they contain identical  GenomeInfo  objects.  The primary \"innovation\" of these types is that genome locations are stored as the 1-based index into the linear genome of concatenated chromosomes described by the immutable  GenomeInfo  object. The relevant chromosome for this  genopos  can be looked up efficiently as the  GenomeInfo  holds the  cumsum  of the chromosome lengths. Using binary search and the usual optimization for a sorted vector of queries, these lookups are O(numpositions * log(numchromosomes)) in the worst case and O(numpositions) in the best case.", 
            "title": "Implementation"
        }, 
        {
            "location": "/#creation", 
            "text": "GenomeInfo  and  GenomicPositions  objects can be created as follows:  using GenomicVectors\n\nchrinfo = GenomeInfo( hg19 ,[ chr1 , chr2 , chrX ],Int64[3e5,2e5,1e4])\nchrs = [ chr1 , chr2 , chr2 , chrX ]\npos = Int64[3e5,1.8e5,1.9e5,1e4]\n\nx = GenomicPositions(pos,chrs,chrinfo)\n\ngpos = genopos(pos,chrs,chrinfo)\ny = GenomicPositions(gpos,chrinfo)", 
            "title": "Creation"
        }, 
        {
            "location": "/#describing", 
            "text": "GenomeInfo  objects have various accessors that describe the chomosomes and their boundaries in the concatenated, linear genome. They are also immutable so that the meaning of indices into a concatenated genome cannot change unexpectedly. Objects that contain a  GenomeInfo  implement the same methods.  chrinfo = GenomeInfo( hg19 ,[ chr1 , chr2 , chrX ],Int64[3e5,2e5,1e4])\ngenome(chrinfo)\nchr_names(chrinfo)\nchr_ends(chrinfo)\nchr_lengths(chrinfo)\nchr_offsets(chrinfo)\n\nchrs = [ chr1 , chr2 , chr2 , chrX ]\npos = Int64[3e5,1.8e5,1.9e5,1e4]\nx = GenomicPositions(pos,chrs,chrinfo)\nchr_names(x)\nchr_ends(x)\nchr_lengths(x)\nchr_offsets(x)  Similarly,  GenomicPositions  and similar objects can describe the positions they represent.  GenomicRanges  and  GenomicPositions  have the same API, for interchangeability, even when functions are more naturally position- or range-related. Some of these functions are shared with  RLEVectors  as ranges and runs have much in common.  chrinfo = GenomeInfo( hg19 ,[ chr1 , chr2 , chrX ],Int64[3e5,2e5,1e4])\nchrs = [ chr1 , chr2 , chr2 , chrX ]\npos = Int64[3e5,1.8e5,1.9e5,1e4]\nx = GenomicPositions(pos,chrs,chrinfo)\nchrpos(x)\nstarts(x)\nends(x)\nwidths(x)", 
            "title": "Describing"
        }, 
        {
            "location": "/#working-with-locations", 
            "text": "Genome locations may be modified (slid along the genome, resized, etc.) in various ways, but operations that would exceed the bounds of the relevant chromosome generate errors.  Queries of a genomic vector are only relevant in the context of a specific genome. Therefore, comparisons are only implemented between the collection of types that can be checked for identical  GenomeInfo  information.  Standard vector item matching operations require identity of items, rather than overlapping ranges. Overlap operations are implemented as distinct functions, as in Bioconductor.  chrinfo = GenomeInfo( GRCh38 ,[ chr1 , chr2 , chr3 , chrX , chrY , chrM ],Int64[3e5,2e5,1e4,5e4,2e3,1e3])\nx = GenomicPositions( [ 200,100,150,50,500,20000], [ chr2 , chr2 , chr2 , chrM , chrY , chr1 ], chrinfo)\ny = GenomicPositions( [ 220,100,50,50,420,10000], [ chr2 , chr2 , chr2 , chrM , chrY , chr1 ], chrinfo)\nx in y\nindexin(x,y)\nslide!(x,20)\nx in y\noverlaps(x,y)", 
            "title": "Working with locations"
        }, 
        {
            "location": "/#ordering", 
            "text": "Given the linearized representation of the genome, ordering operations are done with respect first to position within a chromosome and then to the order of chromosomes specified in the contained  GenomeInfo  object. Stand, for types that implement it, is not considered in ordering. This is different than how strand is handled in R's Bioconductor classes.  using DataFrames\nchrinfo = GenomeInfo( GRCh38 ,[ chr1 , chr2 , chr3 , chrX , chrY , chrM ],Int64[3e5,2e5,1e4,5e4,2e3,1e3])\nx = GenomicPositions( [ 200,100,150,50,500,20000], [ chr2 , chr2 , chr2 , chrM , chrY , chr1 ], chrinfo)\nsortperm(x)\nsort!(x,rev=true)\nissorted(x)\ny = sort(x)\nissorted(y)\nconvert(DataFrame, y)", 
            "title": "Ordering"
        }, 
        {
            "location": "/#intersection-overlap-operations", 
            "text": "Currently we depend on Bio.jl and the  IntervalCollection  for overlap queries. We provide  convert  methods to make  IntervalCollection s. These collections store the genome-scale positions put the genome string in the chromosome string field, resulting in a single tree. We add the index of each interval in the  AbstractGenomicVector  in the metadata slot of each  Interval  which can be used to relate the  IntervalCollection  back to our original object.", 
            "title": "Intersection / overlap operations"
        }, 
        {
            "location": "/NEWS/", 
            "text": "Version 0.0.0\n\n\nSuper-duper dev mode. Basically, don't use this.\n\n\n\n\nVersion 0.1.0\n\n\nBasic functionality in place", 
            "title": "Changelog"
        }, 
        {
            "location": "/NEWS/#version-000", 
            "text": "Super-duper dev mode. Basically, don't use this.", 
            "title": "Version 0.0.0"
        }, 
        {
            "location": "/NEWS/#version-010", 
            "text": "Basic functionality in place", 
            "title": "Version 0.1.0"
        }, 
        {
            "location": "/TODO/", 
            "text": "Features\n\n\n\n\n[ ] \nshow\n for GenomicRanges should covert genoPos to chrPos\n\n\n[x] as.string for GenomicPositions\n\n\n[ ] as.string for GenomicRanges\n\n\n[x] get both chr and pos for GenomicPositions\n\n\n[ ] get both chr and pos for GenomicRanges\n\n\n[ ] overlap(::GenomicRanges,::GenomicPositions)\n\n\n[ ] overlap(::GenomicRanges,::GenomicRanges)\n\n\n[x] convert method: GenomicPositions to DataFrame\n\n\n[ ] convert method: GenomicRanges to DataFrame\n\n\n[x] convert method: GenomicPositions to String via DataFrame\n\n\n[ ] convert method: GenomicRanges to String via DataFrame\n\n\n[x] == for GenomicInfo\n\n\n[ ] getter for GenomeInfo chr_names hash?\n\n\n[ ] getindex for GenomicPositions should return a GenomicPositions\n\n\n[x] constructor for just genopos and chrinfo, needed for subsetting\n\n\n[x] finish indexing\n\n\n[ ] make convert to DataFrame more like chrpos and chr\n\n\n[x] use DataStructures.OrderedDict or NamedArray for GenomeInfo\n\n\n\n\n\n\nDecisions\n\n\n\n\n[x] GenomicInfo must store lengths or ends, offsets loses last length\n\n\n[x] For converting genome position to chromosome position, some kind of search for pos + offset positions in vector of offsets. Linear might be fine (or faster) since we just have ~25 values to search in.\n\n\n[ ] Maybe store GenomeInfo as an RLEVector of chr names? We'd get\n\n\n\n\nsome useful stuff like rwidth and length for free.\n\n\n\n\n[x] Maybe store GenomeInfo as a runend vector and a name -\n index hash while NamedArrays sorts out their method ambiguity warnings?\n\n\n[x] Should scalar indexing give a scalar? I guess so, but genpos value?  Dimension dropping is weird.\n\n\n[x] Rename package to GenomicVectors?\n\n\n[ ] Make things like chromosomes, chrpos, width generator functions?\n\n\n[ ] does it make sense to take or return scalars in operations on GenomicVectors, e.g. pop! and push!  ?\n\n\n[ ] Should starts and ends for GenomicRanges be a n x 2 matrix or two vectors? Matrix is nice for sortrows. Also if I want to have a view, I can have just one.\n\n\n[ ] Should chromosome names be symbols rather than strings?\n\n\n\n\n\n\nImprovements\n\n\n\n\n[x] Swap GenomicPositions inner- and outer-constructors\n\n\n[ ] Genomic* constructors should do something about matching type of\n\n\n\n\nkeys on GenomeInfo and type of chrs\n\n\n\n\n[ ] show on GP should use convert(String,gp)\n\n\n[x] store [0 ; chr_ends] in GenomeInfo chr_ends, chr_offsets,\n\n\n\n\nchr_lengths then just x[2:end], x[1:end-1], diff(x)\n\n\n\n\n[ ] Make sure my hash and == are what AutoHashEquals would say\n\n\n[ ] chrpos, chromosomes, genopos util functions so similar. What can I factor out?\n\n\n[ ] sort(GR) should use sortperm(each(GR))\n\n\n[ ] getindex and setindex for i::Int should use Interval not tuple\n\n\n\n\n\n\nBugs\n\n\n\n\n[x] chromosomes function contains type instability\n\n\n[x] sortperm(x::GenomicRanges; rev=false) is inconsistent with sort(x::GenomicRanges; rev=false)", 
            "title": "TODO"
        }, 
        {
            "location": "/TODO/#features", 
            "text": "[ ]  show  for GenomicRanges should covert genoPos to chrPos  [x] as.string for GenomicPositions  [ ] as.string for GenomicRanges  [x] get both chr and pos for GenomicPositions  [ ] get both chr and pos for GenomicRanges  [ ] overlap(::GenomicRanges,::GenomicPositions)  [ ] overlap(::GenomicRanges,::GenomicRanges)  [x] convert method: GenomicPositions to DataFrame  [ ] convert method: GenomicRanges to DataFrame  [x] convert method: GenomicPositions to String via DataFrame  [ ] convert method: GenomicRanges to String via DataFrame  [x] == for GenomicInfo  [ ] getter for GenomeInfo chr_names hash?  [ ] getindex for GenomicPositions should return a GenomicPositions  [x] constructor for just genopos and chrinfo, needed for subsetting  [x] finish indexing  [ ] make convert to DataFrame more like chrpos and chr  [x] use DataStructures.OrderedDict or NamedArray for GenomeInfo", 
            "title": "Features"
        }, 
        {
            "location": "/TODO/#decisions", 
            "text": "[x] GenomicInfo must store lengths or ends, offsets loses last length  [x] For converting genome position to chromosome position, some kind of search for pos + offset positions in vector of offsets. Linear might be fine (or faster) since we just have ~25 values to search in.  [ ] Maybe store GenomeInfo as an RLEVector of chr names? We'd get   some useful stuff like rwidth and length for free.   [x] Maybe store GenomeInfo as a runend vector and a name -  index hash while NamedArrays sorts out their method ambiguity warnings?  [x] Should scalar indexing give a scalar? I guess so, but genpos value?  Dimension dropping is weird.  [x] Rename package to GenomicVectors?  [ ] Make things like chromosomes, chrpos, width generator functions?  [ ] does it make sense to take or return scalars in operations on GenomicVectors, e.g. pop! and push!  ?  [ ] Should starts and ends for GenomicRanges be a n x 2 matrix or two vectors? Matrix is nice for sortrows. Also if I want to have a view, I can have just one.  [ ] Should chromosome names be symbols rather than strings?", 
            "title": "Decisions"
        }, 
        {
            "location": "/TODO/#improvements", 
            "text": "[x] Swap GenomicPositions inner- and outer-constructors  [ ] Genomic* constructors should do something about matching type of   keys on GenomeInfo and type of chrs   [ ] show on GP should use convert(String,gp)  [x] store [0 ; chr_ends] in GenomeInfo chr_ends, chr_offsets,   chr_lengths then just x[2:end], x[1:end-1], diff(x)   [ ] Make sure my hash and == are what AutoHashEquals would say  [ ] chrpos, chromosomes, genopos util functions so similar. What can I factor out?  [ ] sort(GR) should use sortperm(each(GR))  [ ] getindex and setindex for i::Int should use Interval not tuple", 
            "title": "Improvements"
        }, 
        {
            "location": "/TODO/#bugs", 
            "text": "[x] chromosomes function contains type instability  [x] sortperm(x::GenomicRanges; rev=false) is inconsistent with sort(x::GenomicRanges; rev=false)", 
            "title": "Bugs"
        }, 
        {
            "location": "/api/", 
            "text": "The GenomicVectors Types and Methods\n\n\n\n\nIndex\n\n\n\n\nGenomicVectors.GenomeInfo\n\n\nGenomicVectors.GenomicPositions\n\n\nGenomicVectors.GenomicRanges\n\n\nGenomicVectors.chromosomes\n\n\nGenomicVectors.chrpos\n\n\nGenomicVectors.genopos\n\n\nGenomicVectors.nearest\n\n\nGenomicVectors.overlap\n\n\nGenomicVectors.overlapin\n\n\nRLEVectors.ends\n\n\nRLEVectors.starts\n\n\nRLEVectors.widths\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nGenomicVectors.GenomeInfo\n \n \nType\n.\n\n\nGenomeInfo Type\n\n\nA GenomeInfo holds information about a genome including its name, chromosome names,  chromosome lengths and chromosome offsets into a concatenated, linear genome (genopos). Indexing returns the genopos end of the indexed chromosome.\n\n\nExamples\n\n\nchrinfo = GenomeInfo(\nhg19\n,[\nchr1\n,\nchr2\n,\nchrX\n],Int64[3e5,2e5,1e4])\ngenome(chrinfo)\nchr_names(chrinfo)\nchr_lengths(chrinfo)\nchr_ends(chrinfo)\nchr_offsets(chrinfo)\nchrinfo[2] # 5e5\n\n\n\n\nsource\n\n\n#\n\n\nGenomicVectors.GenomicPositions\n \n \nType\n.\n\n\nGenomicPositions(chrpos, chromosomes, genomeinfo)\nGenomicPositions(genopos, genomeinfo)\n\n\n\n\nRepresents single-nucleotide positions in a genome.\n\n\nThis type uses its (immutable) \nGenomeInfo\n slot object to describe corresponding genome and     positions can be expressed relative to this concatenated, linearized genome or relative     to the chromosome containing a given position.\n\n\nSorting is by chromosome, as ordered by chrinfo,\n\n\nBy convention, all postions in a \nGenomicPositions\n are considered to be on the plus strand.\n\n\n\n\nExamples\n\n\n    genomeinfo = GenomeInfo(\nhg19\n,[\nchr1\n,\nchr2\n,\nchrX\n],Int64[3e5,2e5,1e4])\n    chrs = [\nchr2\n,\nchr1\n,\nchr2\n,\nchrX\n]\n    pos = Int64[3e4,4.2e3,1.9e5,1e4]\n    gpos = genopos(pos,chrs,chrinfo)\n    x = GenomicPositions(pos,chrs,genomeinfo)\n    y = GenomicPositions(gpos,genomeinfo)\n    same_genome(x, y)\n    sort!(y)\n    convert(DataFrame, y)\n\n\n\n\nsource\n\n\n#\n\n\nGenomicVectors.GenomicRanges\n \n \nType\n.\n\n\nGenomicRanges\n\n\nGenomicRanges\n represent closed ranges in a genome. This type uses its (immutable) \nGenomeInfo\n slot object to describe corresponding genome and positions can be expressed relative to this concatenated, linearized genome or relative to the chromosome containing a given position.\n\n\nExamples\n\n\nchrinfo = GenomeInfo(\nhg19\n,[\nchr1\n,\nchr2\n,\nchrX\n],Int64[3e5,2e5,1e4])\nchrs = [\nchr1\n,\nchr2\n,\nchr2\n,\nchrX\n]\nstarts = [100, 200, 300, 400]\nends = [120, 240, 350, 455]\ngr = GenomicRanges(chrs,starts,ends,chrinfo)\n\n\n\n\nIndexing\n\n\nIndexing a \nGenomicRanges\n with an array produces a new \nGenomicRanges\n.\n\n\nGetting/setting by a scalar gives/takes a Bio.Intervals.Interval. The leftposition and rightposition in this Interval must be in genome location units and correspond to the same chromosome. The seqname must match the genome of the GenomicRanges. Outgoing Intervals will have the index \ni\n as their metadata. This makes it possible to obtain the original ordering if Intervals after conversion to, say, an IntervalCollection. Any metadata  for an incoming Interval is ignored.\n\n\nThe \neach\n function produces an iterator of (start,end) two-tuples in genome location units. This is use for many internal functions, like sorting. This is intentionally similar to \nRLEVectors.each\n.\n\n\nsource\n\n\n\n\nGenome Location API\n\n\nGenomicVectors.jl\n has ... All \nAbstractGenomicVector\ns implement the API for \nGenomeInfo\n for access to their genome descriptions.\n\n\n\n\nAccessing position info\n\n\n#\n\n\nRLEVectors.starts\n \n \nFunction\n.\n\n\nRLEVectors\n\n\nRLEVectors\n is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.\n\n\nRLEVectors\n can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector with \ncollect\n.\n\n\nAliases\n\n\nSeveral aliases are defined for specific types of RLEVector (or collections thereof).\n\n\nFloatRle              RLEVector{Float64,UInt32}\nIntegerRle            RLEVector{Int64,UInt32}\nBoolRle               RLEVector{Bool,UInt32}\nStringRle             RLEVector{String,UInt32}\nRLEVectorList{T1,T2}  Vector{ RLEVector{T1,T2} }\n\n\n\n\nConstructors\n\n\nRLEVector\ns can be created by specifying a vector to compress or the runvalues and run ends.\n\n\nx = RLEVector([1,1,2,2,3,3,4,4,4])\nx = RLEVector([4,5,6],[3,6,9])\n\n\n\n\nDescribing \nRLEVector\n objects\n\n\nRLEVector\ns implement the usual descriptive functions for an array as well as some that are specific to the type.\n\n\n\n\nlength(x)\n The full length of the vector, uncompressed\n\n\nsize(x)\n Same as \nlength\n, as for any other vector\n\n\nsize(x,dim)\n Returns \n(length(x),1) for dim == 1\n\n\nstarts(x)\n The index of the beginning of each run\n\n\nwidths(x)\n The width of each run\n\n\nends(x)\n The index of the end of each run\n\n\nvalues(x)\n The data value for each run\n\n\nisempty(x)\n Returns boolean, as for any other vector\n\n\nnrun(x)\n Returns the number of runs represented in the array\n\n\neltype(x)\n Returns the element type of the runs\n\n\nendtype(x)\n Returns the element type of the run ends\n\n\n\n\nsource\n\n\n#\n\n\nRLEVectors.widths\n \n \nFunction\n.\n\n\nRLEVectors\n\n\nRLEVectors\n is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.\n\n\nRLEVectors\n can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector with \ncollect\n.\n\n\nAliases\n\n\nSeveral aliases are defined for specific types of RLEVector (or collections thereof).\n\n\nFloatRle              RLEVector{Float64,UInt32}\nIntegerRle            RLEVector{Int64,UInt32}\nBoolRle               RLEVector{Bool,UInt32}\nStringRle             RLEVector{String,UInt32}\nRLEVectorList{T1,T2}  Vector{ RLEVector{T1,T2} }\n\n\n\n\nConstructors\n\n\nRLEVector\ns can be created by specifying a vector to compress or the runvalues and run ends.\n\n\nx = RLEVector([1,1,2,2,3,3,4,4,4])\nx = RLEVector([4,5,6],[3,6,9])\n\n\n\n\nDescribing \nRLEVector\n objects\n\n\nRLEVector\ns implement the usual descriptive functions for an array as well as some that are specific to the type.\n\n\n\n\nlength(x)\n The full length of the vector, uncompressed\n\n\nsize(x)\n Same as \nlength\n, as for any other vector\n\n\nsize(x,dim)\n Returns \n(length(x),1) for dim == 1\n\n\nstarts(x)\n The index of the beginning of each run\n\n\nwidths(x)\n The width of each run\n\n\nends(x)\n The index of the end of each run\n\n\nvalues(x)\n The data value for each run\n\n\nisempty(x)\n Returns boolean, as for any other vector\n\n\nnrun(x)\n Returns the number of runs represented in the array\n\n\neltype(x)\n Returns the element type of the runs\n\n\nendtype(x)\n Returns the element type of the run ends\n\n\n\n\nsource\n\n\n#\n\n\nRLEVectors.ends\n \n \nFunction\n.\n\n\nRLEVectors\n\n\nRLEVectors\n is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.\n\n\nRLEVectors\n can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector with \ncollect\n.\n\n\nAliases\n\n\nSeveral aliases are defined for specific types of RLEVector (or collections thereof).\n\n\nFloatRle              RLEVector{Float64,UInt32}\nIntegerRle            RLEVector{Int64,UInt32}\nBoolRle               RLEVector{Bool,UInt32}\nStringRle             RLEVector{String,UInt32}\nRLEVectorList{T1,T2}  Vector{ RLEVector{T1,T2} }\n\n\n\n\nConstructors\n\n\nRLEVector\ns can be created by specifying a vector to compress or the runvalues and run ends.\n\n\nx = RLEVector([1,1,2,2,3,3,4,4,4])\nx = RLEVector([4,5,6],[3,6,9])\n\n\n\n\nDescribing \nRLEVector\n objects\n\n\nRLEVector\ns implement the usual descriptive functions for an array as well as some that are specific to the type.\n\n\n\n\nlength(x)\n The full length of the vector, uncompressed\n\n\nsize(x)\n Same as \nlength\n, as for any other vector\n\n\nsize(x,dim)\n Returns \n(length(x),1) for dim == 1\n\n\nstarts(x)\n The index of the beginning of each run\n\n\nwidths(x)\n The width of each run\n\n\nends(x)\n The index of the end of each run\n\n\nvalues(x)\n The data value for each run\n\n\nisempty(x)\n Returns boolean, as for any other vector\n\n\nnrun(x)\n Returns the number of runs represented in the array\n\n\neltype(x)\n Returns the element type of the runs\n\n\nendtype(x)\n Returns the element type of the run ends\n\n\n\n\nsource\n\n\n#\n\n\nGenomicVectors.genopos\n \n \nFunction\n.\n\n\nGiven chromosome and chromosome position information and a description of the chromosomes (a GenoPos object), calculate the corresponding positions in the linear genome.\n\n\nsource\n\n\n#\n\n\nGenomicVectors.chrpos\n \n \nFunction\n.\n\n\nGiven positions in the linear genome, calculate the position on the relevant chromosome.\n\n\nsource\n\n\n#\n\n\nGenomicVectors.chromosomes\n \n \nFunction\n.\n\n\nGiven positions in the linear genome, calculate the position on the relevant chromosome.\n\n\nsource\n\n\n\n\nModifying positions\n\n\nslide\nslide!\n\n\n\n\n\n\nQuerying positions\n\n\nAs in Bioconductor, location query operations discriminate between exact and overlapping matches. In addition to exact versus overlapping coordinates, exact matching includes strand, while overlap matching does not. In \nGenomcVectors.jl\n, the standard set operations use exact matching and custom overlap functions are defined for \nAbstractGenomicVector\n.\n\n\n\n\nOverlap function\n\n\noverlap\noverlapin\noverlapindex\nnearest", 
            "title": "API"
        }, 
        {
            "location": "/api/#the-genomicvectors-types-and-methods", 
            "text": "", 
            "title": "The GenomicVectors Types and Methods"
        }, 
        {
            "location": "/api/#index", 
            "text": "GenomicVectors.GenomeInfo  GenomicVectors.GenomicPositions  GenomicVectors.GenomicRanges  GenomicVectors.chromosomes  GenomicVectors.chrpos  GenomicVectors.genopos  GenomicVectors.nearest  GenomicVectors.overlap  GenomicVectors.overlapin  RLEVectors.ends  RLEVectors.starts  RLEVectors.widths", 
            "title": "Index"
        }, 
        {
            "location": "/api/#types", 
            "text": "#  GenomicVectors.GenomeInfo     Type .  GenomeInfo Type  A GenomeInfo holds information about a genome including its name, chromosome names,  chromosome lengths and chromosome offsets into a concatenated, linear genome (genopos). Indexing returns the genopos end of the indexed chromosome.  Examples  chrinfo = GenomeInfo( hg19 ,[ chr1 , chr2 , chrX ],Int64[3e5,2e5,1e4])\ngenome(chrinfo)\nchr_names(chrinfo)\nchr_lengths(chrinfo)\nchr_ends(chrinfo)\nchr_offsets(chrinfo)\nchrinfo[2] # 5e5  source  #  GenomicVectors.GenomicPositions     Type .  GenomicPositions(chrpos, chromosomes, genomeinfo)\nGenomicPositions(genopos, genomeinfo)  Represents single-nucleotide positions in a genome.  This type uses its (immutable)  GenomeInfo  slot object to describe corresponding genome and     positions can be expressed relative to this concatenated, linearized genome or relative     to the chromosome containing a given position.  Sorting is by chromosome, as ordered by chrinfo,  By convention, all postions in a  GenomicPositions  are considered to be on the plus strand.   Examples      genomeinfo = GenomeInfo( hg19 ,[ chr1 , chr2 , chrX ],Int64[3e5,2e5,1e4])\n    chrs = [ chr2 , chr1 , chr2 , chrX ]\n    pos = Int64[3e4,4.2e3,1.9e5,1e4]\n    gpos = genopos(pos,chrs,chrinfo)\n    x = GenomicPositions(pos,chrs,genomeinfo)\n    y = GenomicPositions(gpos,genomeinfo)\n    same_genome(x, y)\n    sort!(y)\n    convert(DataFrame, y)  source  #  GenomicVectors.GenomicRanges     Type .  GenomicRanges  GenomicRanges  represent closed ranges in a genome. This type uses its (immutable)  GenomeInfo  slot object to describe corresponding genome and positions can be expressed relative to this concatenated, linearized genome or relative to the chromosome containing a given position.  Examples  chrinfo = GenomeInfo( hg19 ,[ chr1 , chr2 , chrX ],Int64[3e5,2e5,1e4])\nchrs = [ chr1 , chr2 , chr2 , chrX ]\nstarts = [100, 200, 300, 400]\nends = [120, 240, 350, 455]\ngr = GenomicRanges(chrs,starts,ends,chrinfo)  Indexing  Indexing a  GenomicRanges  with an array produces a new  GenomicRanges .  Getting/setting by a scalar gives/takes a Bio.Intervals.Interval. The leftposition and rightposition in this Interval must be in genome location units and correspond to the same chromosome. The seqname must match the genome of the GenomicRanges. Outgoing Intervals will have the index  i  as their metadata. This makes it possible to obtain the original ordering if Intervals after conversion to, say, an IntervalCollection. Any metadata  for an incoming Interval is ignored.  The  each  function produces an iterator of (start,end) two-tuples in genome location units. This is use for many internal functions, like sorting. This is intentionally similar to  RLEVectors.each .  source", 
            "title": "Types"
        }, 
        {
            "location": "/api/#genome-location-api", 
            "text": "GenomicVectors.jl  has ... All  AbstractGenomicVector s implement the API for  GenomeInfo  for access to their genome descriptions.", 
            "title": "Genome Location API"
        }, 
        {
            "location": "/api/#accessing-position-info", 
            "text": "#  RLEVectors.starts     Function .  RLEVectors  RLEVectors  is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.  RLEVectors  can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector with  collect .  Aliases  Several aliases are defined for specific types of RLEVector (or collections thereof).  FloatRle              RLEVector{Float64,UInt32}\nIntegerRle            RLEVector{Int64,UInt32}\nBoolRle               RLEVector{Bool,UInt32}\nStringRle             RLEVector{String,UInt32}\nRLEVectorList{T1,T2}  Vector{ RLEVector{T1,T2} }  Constructors  RLEVector s can be created by specifying a vector to compress or the runvalues and run ends.  x = RLEVector([1,1,2,2,3,3,4,4,4])\nx = RLEVector([4,5,6],[3,6,9])  Describing  RLEVector  objects  RLEVector s implement the usual descriptive functions for an array as well as some that are specific to the type.   length(x)  The full length of the vector, uncompressed  size(x)  Same as  length , as for any other vector  size(x,dim)  Returns  (length(x),1) for dim == 1  starts(x)  The index of the beginning of each run  widths(x)  The width of each run  ends(x)  The index of the end of each run  values(x)  The data value for each run  isempty(x)  Returns boolean, as for any other vector  nrun(x)  Returns the number of runs represented in the array  eltype(x)  Returns the element type of the runs  endtype(x)  Returns the element type of the run ends   source  #  RLEVectors.widths     Function .  RLEVectors  RLEVectors  is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.  RLEVectors  can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector with  collect .  Aliases  Several aliases are defined for specific types of RLEVector (or collections thereof).  FloatRle              RLEVector{Float64,UInt32}\nIntegerRle            RLEVector{Int64,UInt32}\nBoolRle               RLEVector{Bool,UInt32}\nStringRle             RLEVector{String,UInt32}\nRLEVectorList{T1,T2}  Vector{ RLEVector{T1,T2} }  Constructors  RLEVector s can be created by specifying a vector to compress or the runvalues and run ends.  x = RLEVector([1,1,2,2,3,3,4,4,4])\nx = RLEVector([4,5,6],[3,6,9])  Describing  RLEVector  objects  RLEVector s implement the usual descriptive functions for an array as well as some that are specific to the type.   length(x)  The full length of the vector, uncompressed  size(x)  Same as  length , as for any other vector  size(x,dim)  Returns  (length(x),1) for dim == 1  starts(x)  The index of the beginning of each run  widths(x)  The width of each run  ends(x)  The index of the end of each run  values(x)  The data value for each run  isempty(x)  Returns boolean, as for any other vector  nrun(x)  Returns the number of runs represented in the array  eltype(x)  Returns the element type of the runs  endtype(x)  Returns the element type of the run ends   source  #  RLEVectors.ends     Function .  RLEVectors  RLEVectors  is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.  RLEVectors  can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector with  collect .  Aliases  Several aliases are defined for specific types of RLEVector (or collections thereof).  FloatRle              RLEVector{Float64,UInt32}\nIntegerRle            RLEVector{Int64,UInt32}\nBoolRle               RLEVector{Bool,UInt32}\nStringRle             RLEVector{String,UInt32}\nRLEVectorList{T1,T2}  Vector{ RLEVector{T1,T2} }  Constructors  RLEVector s can be created by specifying a vector to compress or the runvalues and run ends.  x = RLEVector([1,1,2,2,3,3,4,4,4])\nx = RLEVector([4,5,6],[3,6,9])  Describing  RLEVector  objects  RLEVector s implement the usual descriptive functions for an array as well as some that are specific to the type.   length(x)  The full length of the vector, uncompressed  size(x)  Same as  length , as for any other vector  size(x,dim)  Returns  (length(x),1) for dim == 1  starts(x)  The index of the beginning of each run  widths(x)  The width of each run  ends(x)  The index of the end of each run  values(x)  The data value for each run  isempty(x)  Returns boolean, as for any other vector  nrun(x)  Returns the number of runs represented in the array  eltype(x)  Returns the element type of the runs  endtype(x)  Returns the element type of the run ends   source  #  GenomicVectors.genopos     Function .  Given chromosome and chromosome position information and a description of the chromosomes (a GenoPos object), calculate the corresponding positions in the linear genome.  source  #  GenomicVectors.chrpos     Function .  Given positions in the linear genome, calculate the position on the relevant chromosome.  source  #  GenomicVectors.chromosomes     Function .  Given positions in the linear genome, calculate the position on the relevant chromosome.  source", 
            "title": "Accessing position info"
        }, 
        {
            "location": "/api/#modifying-positions", 
            "text": "slide\nslide!", 
            "title": "Modifying positions"
        }, 
        {
            "location": "/api/#querying-positions", 
            "text": "As in Bioconductor, location query operations discriminate between exact and overlapping matches. In addition to exact versus overlapping coordinates, exact matching includes strand, while overlap matching does not. In  GenomcVectors.jl , the standard set operations use exact matching and custom overlap functions are defined for  AbstractGenomicVector .", 
            "title": "Querying positions"
        }, 
        {
            "location": "/api/#overlap-function", 
            "text": "overlap\noverlapin\noverlapindex\nnearest", 
            "title": "Overlap function"
        }, 
        {
            "location": "/future/", 
            "text": "Ideas for future development\n\n\n\n\nMaintaining performance via sortedness and views\n\n\nThe classes in this package serve dual roles: they server as annotation of arbitrary collections of genomic positions, but they also as indices into that annotation. By allowing an arbitrary ordering of features (genome positions, ranges etc.) these classes can represent an ordering of their associated data (e.g. sorting by significance). Additionally, by not breaking data up into chunks by chromosome, we enable many conveniences.\n\n\nThese ordering decisions have performance implications. The current strategy is to support faster searching of genome positions when data are arranged in genome order. For example, looking up the relevant chromosome for \nn\n data points in \nk\n chromosomes is is \nO(n)\n for sorted positions and \nO(n * log(k))\n for unordered data. (A single genome -\n chromosome lookup is always \nO(log(k))\n as the chromosome boundary data are maintained in sorted order).\n\n\nIn the future we may attempt to maintain the benefits arbitrary ordering and also of fast searching by maintaining position data in an efficient representation (ordered, IntervalTree, NC list, etc.) in addition to a \nView\n representing the arbitrary ordering.", 
            "title": "The Future"
        }, 
        {
            "location": "/future/#ideas-for-future-development", 
            "text": "", 
            "title": "Ideas for future development"
        }, 
        {
            "location": "/future/#maintaining-performance-via-sortedness-and-views", 
            "text": "The classes in this package serve dual roles: they server as annotation of arbitrary collections of genomic positions, but they also as indices into that annotation. By allowing an arbitrary ordering of features (genome positions, ranges etc.) these classes can represent an ordering of their associated data (e.g. sorting by significance). Additionally, by not breaking data up into chunks by chromosome, we enable many conveniences.  These ordering decisions have performance implications. The current strategy is to support faster searching of genome positions when data are arranged in genome order. For example, looking up the relevant chromosome for  n  data points in  k  chromosomes is is  O(n)  for sorted positions and  O(n * log(k))  for unordered data. (A single genome -  chromosome lookup is always  O(log(k))  as the chromosome boundary data are maintained in sorted order).  In the future we may attempt to maintain the benefits arbitrary ordering and also of fast searching by maintaining position data in an efficient representation (ordered, IntervalTree, NC list, etc.) in addition to a  View  representing the arbitrary ordering.", 
            "title": "Maintaining performance via sortedness and views"
        }
    ]
}